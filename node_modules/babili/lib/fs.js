"use strict";

var fs = require("fs");
var path = require("path");
var readdir = require("fs-readdir-recursive");
var outputFileSync = require("output-file-sync");
var babili = require("./");
var EXTENSIONS = [".js", ".mjs"];

module.exports.processFiles = function (fileList, options) {
  var _detachOptions = detachOptions(options),
      fileOpts = _detachOptions.fileOpts,
      babiliOpts = _detachOptions.options;

  var stdin = fileOpts.stdin,
      outFile = fileOpts.outFile,
      outDir = fileOpts.outDir;

  if (stdin) {
    readStdin().then(function (input) {
      var _babili = babili(input, babiliOpts),
          code = _babili.code;
      // write to console if ouput file is not specified


      if (outFile === void 0) {
        process.stdout.write(code);
      } else {
        fs.writeFileSync(path.resolve(outDir), code, "utf-8");
      }
    });
  } else {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = fileList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var filename = _step.value;

        handle(filename, fileOpts, babiliOpts);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
};

function handle(filename, fileOpts, babiliOpts) {
  if (!fs.existsSync(filename)) return;

  var outFile = fileOpts.outFile;

  if (outFile !== undefined) {
    transform(filename, outFile, babiliOpts);
    return;
  }

  var stat = fs.statSync(filename);
  if (stat.isDirectory()) {
    var dirname = filename;
    readdir(dirname).forEach(function (filename) {
      var src = path.join(dirname, filename);
      handleFile(src, filename, fileOpts, babiliOpts);
    });
  } else {
    handleFile(filename, filename, fileOpts, babiliOpts);
  }
}

function handleFile(src, relative, fileOpts, babiliOpts) {
  var ext = getValidFileExt(relative);
  if (ext === undefined) {
    return;
  }
  var outDir = fileOpts.outDir;

  var dest = void 0;
  var filename = getFileName(relative, ext);
  if (outDir) {
    dest = path.join(outDir, path.dirname(relative), filename);
  } else {
    dest = path.join(path.dirname(src), filename);
  }
  transform(src, dest, babiliOpts);
}

function transform(src, dest, babiliOpts) {
  var input = fs.readFileSync(src, "utf-8");

  var _babili2 = babili(input, babiliOpts),
      code = _babili2.code;

  outputFileSync(dest, code, "utf-8");
}

function detachOptions(options) {
  var cliOpts = ["stdin", "outFile", "outDir"];
  var fileOpts = {};
  cliOpts.forEach(function (k) {
    fileOpts[k] = options[k];
    delete options[k];
  });

  return { fileOpts, options };
}

function readStdin() {
  var code = "";
  var stdin = process.stdin;

  return new Promise(function (resolve) {
    stdin.setEncoding("utf8");

    stdin.on("readable", function () {
      var chunk = process.stdin.read();
      if (chunk !== null) code += chunk;
    });

    stdin.on("end", function () {
      resolve(code);
    });
  });
}

function getValidFileExt(filename) {
  var ext = path.extname(filename);
  var isValidExt = EXTENSIONS.some(function (e) {
    return e.indexOf(ext) >= 0;
  });

  if (isValidExt) {
    return ext;
  }
  return "";
}

function getFileName(filePath, ext) {
  var filename = path.basename(filePath, ext);
  filename = filename.indexOf(".min") >= 0 ? filename : `${filename}.min`;
  return `${filename}${ext}`;
}